<!-- Copyright (C) The IETF Trust (2019) -->
<!-- Copyright (C) The Internet Society (2019) -->

<section anchor="op_LAYOUT_WCC" title="Operation 77: LAYOUT_WCC - Layout Weak Cache Consistency">
  <section toc='exclude' anchor="ss:op_LAYOUT_WCC:A" title="ARGUMENT">
<figure>
 <artwork>
&lt;CODE BEGINS&gt;
/// struct LAYOUT_WCC4args {
///         stateid4        lowa_stateid;
///         layouttype4     lowa_type;
///         opaque          lowa_body&lt;&gt;;
/// };
&lt;CODE ENDS&gt;
 </artwork>
</figure>
  </section>

  <section toc='exclude' anchor="ss:op_LAYOUT_WCC:R" title="RESULT">
<figure>
 <artwork>
&lt;CODE BEGINS&gt;
/// struct LAYOUT_WCC4res {
///         nfsstat4                lowr_status;
/// };
&lt;CODE ENDS&gt;
 </artwork>
</figure>
  </section>

  <section toc='exclude' anchor="ss:op_LAYOUT_WCC:D" title="DESCRIPTION">
    <t>
      When using pNFS (See Section 12 of <xref target='RFC5661' />),
      the client is most likely to be performing file operations to the
      storage device and not the metadata server. With some layout types
      (most notably the flexible files layout type in <xref target='RFC8435' />)
      there is no control protocol between the metadata server and the
      storage device. In order to update the metadata state of the file,
      the metadata server will need to track the metadata state of the
      data file - once the layout is issued, it is not able to see the
      NFSv3 file operations from the client to the storage device. Thus
      the metadata server will be required to query the storage device
      for the data file attributes.
    </t>

    <t>
      For example, with a flexible files layout type, the metadata server
      would issue a NFSv3 GETATTR to the storage device. These queries are
      most likely triggered in response to a NFSv4 GETATTR to the metadata
      server. Not only are these GETATTRs to the storage device individually
      expensive, the storage device can become inundated by a storm of such
      requests. NFSv3 solved a similar issue by having the READ and WRITE
      operations employ a post-operation attribute to report the weak cache
      consistency (WCC) data (See Section 2.6 of <xref target='RFC1813' />).
    </t>

    <t>
      Each NFSv3 operation corresponds to one round trip between the client
      and server. So a WRITE followed by a GETATTR would require two round
      trips. In that scenario, the attribute information retrieved is
      considered to be strict server-client consistency for a cache
      consistency protocol. For NFSv4, the WRITE and GETATTR can be issued
      together inside a compound, which only requires one round trip
      between the client and server. And this is also considered to be
      a strict server-client consistency. In essence, the NFSv4 READ and WRITE
      operations drop the post-operation attributes, allowing the client
      to decide if it needs that information.
    </t>

    <t>
      With the flexible files layout type, the client can leverage the NFSv3
      WCC to service the proxying of times (See <xref target='sec:proxy' />).
      But the granularity of this data is limited. With client
      side mirroring (See Section 8 of <xref target='RFC8435' />), the
      client has to aggregate the N mirrored files in order to send one
      piece of information instead of N pieces of information. Also, the
      client is limited to sending that information only when it returns
      the delegation.
    </t>

    <t>
      The current filehandle and the lowa_stateid identifies the
      particular layout for the LAYOUT_WCC operation. The lowa_type
      indicates how to unpack the layout type specific payload inside
      the lowa_body field. The lowa_type is defined to be a value from
      the IANA registry for "pNFS Layout Types Registry".
    </t>

    <t>
      The lowa_body will contain the data file attributes. The client
      will be responsible for mapping the NFSv3 post-operation attributes
      to those in a fattr4.  Just as the post-operation attributes may be
      ignored by the client, the server may ignore the attributes inside
      the LAYOUT_WCC.  But the server can also use those attributes to
      avoid querying the storage device for the data file attributes.
      Note that as these attributes are optional and there is nothing
      the client can do if the server ignores one, there is no need
      to return a bitmap4 of which attributes were accepted in the
      result of the LAYOUT_WCC.
    </t>
  </section>

  <section anchor="ss:op_LAYOUT_WCC:ff" title="Flex Files Layout Type">
<figure>
 <artwork>
&lt;CODE BEGINS&gt;
/// struct ff_data_server_wcc4 {
///             fattr4               ffdsw_attributes;
/// };
/// 
/// struct ff_mirror_wcc4 {
///             ff_data_server_wcc4  ffmw_data_servers&lt;&gt;;
/// };
/// 
/// struct ff_layout_wcc4 {
///             ff_mirror_wcc4       fflw_mirrors&lt;&gt;;
/// };
&lt;CODE ENDS&gt;
 </artwork>
</figure>

    <t>
      The flex file layout type specific results MUST correspond to the
      ff_layout4 data structure as defined in Section 5.1 of <xref target='RFC8435' />.
      There is a one-to-one correspondence between:

      <list style='symbols'>
        <t> ff_data_server4 -&gt; ff_data_server_wcc4 </t>
        <t> ff_mirror4 -&gt; ff_mirror_wcc4</t>
        <t> ff_layout4 -&gt; ff_layout_wcc4</t>
      </list>

      Each ff_layout4 has an array of ff_mirror4, which have an array of ff_data_server4.
      Based on the current filehandle and the lowa_stateid, the server can match the
      reported attributes.
    </t>

    <t>
      The ffdsw_attributes are processed similar to the obj_attributes in
      the SETATTR arguments (See Section 18.30 of <xref target='RFC5661' />).
    </t>
  </section>
</section>
